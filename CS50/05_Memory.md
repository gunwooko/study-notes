# Memory

## Hexadecimal (16진수)

- 8bits 이진수로 최고의 숫자는 => 1111 1111(2진수) => 255(10진수) = 0xff(16진수)
- 1101 1000(2진수) => 216(10진수) => 0xd8(16진수)
- `0x` 는 그 뒤에 오는 문자들이 16진수임을 알려준다.

컴퓨터과학에서는 숫자를 10진수나 2진수 대신 16진수(Hexadecimal)로 표현하는 경우가 많다. 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문이다. 16진수와 일상생활에서 우리가 사용하는 10진수와 비교하면 그 차이를 알 수 있습니다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.
또한 ASCII코드에 의해 A,B,C 는 10진수로 65, 66, 67에 해당되는데, 컴퓨터가 이해하도록 2진수로 표현하면 01000001 01000010 01000011이 되고 이처럼 길이가 너무 길어지는 문제가 발생한다. 하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해질 수 있다. 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현하는데, 2개의 16진수는 1바이트(8비트)의 2진수로 변환되기 때문에 정보 표현에 매우 유용하다.

## 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 생각해보면, 이 n 이라는 값은 int 타입이므로, 컴퓨터의 메모리 어딘가에 4바이트 만큼의 자리를 차지하며 저장되어 있을 것이다.

C에서는 변수의 메모리상 주소를 받기 위해 `&`이라는 연산자를 사용할 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}

// 예를 들어, 위와 같은 코드를 실행하면 ‘0x7ffe00b3adbc’와 같은 값을 얻을 수 있고, 이는 변수 n의  16진법으로 표현된 메모리의 주소이다.
```

반대로 `*`를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
// 위 코드는 먼저 n의 주소를 얻고, 또 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로 결국 ‘50’이라는 값이 출력이 된다.
```

## 포인터

`*`연산자를 이용해서 포인터 역활을 하는 변수를 선언할 수도 있다.

```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}

```

위 코드를 보면 정수형 변수 n에는 50이라는 값이 저장되어 있다.
그리고 `*p`라는 포인터 변수에 `&n` 이라는 값, 즉 변수 n의 주소를 저장한다.
`int *p` 에서 p앞의 \*는 이 변수가 포인터라는 의미이고, int 는 이 포인터가 int 타입의 변수를 가리킨다는 의미입니다.
따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 n의 주소를 출력하거나, 두 번째 printft문과 같이 포인터 p가 가리키는 변수의 값, 즉 변수 n의 값을 출력할 수도 있다.

## 포인터와 문자열

문자열은 결국 문자의 배열이고, s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타낸다.
가장 마지막의 \0은 0으로 이루어진 바이트로, 문자열의 끝을 표시하는 약속이다.

만일 s에 "MARTIN"이란 문자열을 저장한다면, 변수 s는 결국 이러한 문자열을 가리키는 포인터가 된다. 더 상세히는 문자열의 가장 첫번째 문자의 주소에 있는 s[0]를 가리키게 된다.

```c
#include <stdio.h>

int main(void)
{
    char *s = "MARTIN";
    printf("%s\n", s);
}
// char *s에서 s라는 변수는 문자에 대한 포인터가 되고, “MARTIN”이라는 문자열의 가장 첫 번째 값을 저장하기 때문
```

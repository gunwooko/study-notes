# Memory

## Hexadecimal (16진수)

- 8bits 이진수로 최고의 숫자는 => 1111 1111(2진수) => 255(10진수) = 0xff(16진수)
- 1101 1000(2진수) => 216(10진수) => 0xd8(16진수)
- `0x` 는 그 뒤에 오는 문자들이 16진수임을 알려준다.

컴퓨터과학에서는 숫자를 10진수나 2진수 대신 16진수(Hexadecimal)로 표현하는 경우가 많다. 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문이다. 16진수와 일상생활에서 우리가 사용하는 10진수와 비교하면 그 차이를 알 수 있습니다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.
또한 ASCII코드에 의해 A,B,C 는 10진수로 65, 66, 67에 해당되는데, 컴퓨터가 이해하도록 2진수로 표현하면 01000001 01000010 01000011이 되고 이처럼 길이가 너무 길어지는 문제가 발생한다. 하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해질 수 있다. 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현하는데, 2개의 16진수는 1바이트(8비트)의 2진수로 변환되기 때문에 정보 표현에 매우 유용하다.

## 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 생각해보면, 이 n 이라는 값은 int 타입이므로, 컴퓨터의 메모리 어딘가에 4바이트 만큼의 자리를 차지하며 저장되어 있을 것이다.

C에서는 변수의 메모리상 주소를 받기 위해 `&`이라는 연산자를 사용할 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}

// 예를 들어, 위와 같은 코드를 실행하면 ‘0x7ffe00b3adbc’와 같은 값을 얻을 수 있고, 이는 변수 n의  16진법으로 표현된 메모리의 주소이다.
```

반대로 `*`를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
// 위 코드는 먼저 n의 주소를 얻고, 또 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로 결국 ‘50’이라는 값이 출력이 된다.
```

## 포인터

`*`연산자를 이용해서 포인터 역활을 하는 변수를 선언할 수도 있다.

```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}

```

위 코드를 보면 정수형 변수 n에는 50이라는 값이 저장되어 있다.
그리고 `*p`라는 포인터 변수에 `&n` 이라는 값, 즉 변수 n의 주소를 저장한다.
`int *p` 에서 p앞의 \*는 이 변수가 포인터라는 의미이고, int 는 이 포인터가 int 타입의 변수를 가리킨다는 의미입니다.
따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 n의 주소를 출력하거나, 두 번째 printft문과 같이 포인터 p가 가리키는 변수의 값, 즉 변수 n의 값을 출력할 수도 있다.

## 포인터와 문자열

문자열은 결국 문자의 배열이고, s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타낸다.
가장 마지막의 \0은 0으로 이루어진 바이트로, 문자열의 끝을 표시하는 약속이다.

만일 s에 "MARTIN"이란 문자열을 저장한다면, 변수 s는 결국 이러한 문자열을 가리키는 포인터가 된다. 더 상세히는 문자열의 가장 첫번째 문자의 주소에 있는 s[0]를 가리키게 된다.

```c
#include <stdio.h>

int main(void)
{
    char *s = "MARTIN";
    printf("%s\n", s);
}
// char *s에서 s라는 변수는 문자에 대한 포인터가 되고, “MARTIN”이라는 문자열의 가장 첫 번째 값을 저장하기 때문
```

## 문자열 비교

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
    // 위 코드에서 s라는 포인터 값, 즉 "EMMA"라는 문자열의 가장 첫 값 "E"에 해당하는 메모리 주소를 출력하게 된다.

    printf("%p\n", &s[0]);
    printf("%p\n", &s[1]);
    printf("%p\n", &s[2]);
    printf("%p\n", &s[3]);
    // s가 가리키는 곳을 시작으로 "EMMA"라는 문자열이 이루어진 문자들의 배열이 있다.
    // 위에서는 해당 문자열이 가리키는 주소값을 출력한다.

    printf("%c\n", *s);
    printf("%c\n", *(s+1));
    printf("%c\n", *(s+2));
    printf("%c\n", *(s+3));
    // 즉 주소 값을 하나씩 증가시키면 바로 옆의 문자의 값을 출력할 수 있다.
}
```

만일 문자열이 저장된 변수를 바로 비교하게 되면 변수가 저장되어 있는 주소를 비교하는 것이나 마찬가지이고, 주소는 다르기 때문에 두 문자열이 다르다는 결과가 나올 것이다.
정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나씩 비교해야 한다.

## 문자열 복사

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
// 만일 위와 같이 사용자의 입력값을 받아 s에 저장하고, t를 s로 정의한다.
// 그리고 t를 대문자로 변경후, s와 t를 출력하면 s와 t모두 "Martin"이라고 출력된다. ("martin" 입력)
// 그 이유는 s라는 변수에는 문자열이 아닌, 해당 문자열이 있는 메모리의 주소가 저장되기 때문이다. <string s는 chat *s와 동일하다.>
// 그렇기때문에, t또한 s가 가리키는 동일한 주소를 가리키게 되고, t를 수정하게 되면 s또한 수정되는 것이다.
```

### 두 문자열을 실제로 메모리 상에 복사하기

```c
// 아래와 같이 메모리 할당 함수를 사용하면 된다.
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}

// 이전 코드와 다른 점은 malloc이라는 함수를 이용해서 t를 정의한다는 것이다.
// malloc 이라는 함수는 정해진 크기 만큼 메모리를 할당하는 함수이다.
// 즉 s 문자열의 길이에 널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당한다.
// 그리고 루프를 돌면서 s 문자열 배열에 있는 문자 하나 하나를 t 배열에 복사해주면 된다.
// 이 코드를 컴파일 후 실행시키고 입력값으로 “emma”를 주면 우리가 예상한 대로 s는 “emma”가, t는 “Emma”가 출력되게 된다.
```

## 메모리 할당과 해제

## 메모리 교환, 스텍, 힙

## 파일 쓰기

## 파일 읽기

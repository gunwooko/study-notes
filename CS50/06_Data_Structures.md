# Data Structures

## malloc과 포인터 복습

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```

main 함수 안의 첫 두 줄에서는 포인터 x와 y를 선언한다.

그리고 x에는 malloc 함수를 이용해서 int 자료형 크기에 해당하는 메모리를 할당한다.

그 다음에는 x와 y 포인터가 가리키는 지점에 각각 42와 13을 저장한다.

여기서 문제가 될 만한 부분은 \*y = 13 이다. y는 포인터로만 선언되었을 뿐이지, 어디를 가리킬지에 대해서는 아직 정의가 되지 않았기 때문이다.

따라서 초기화 되지 않은 \*y는 프로그램 어딘가를 임의로 가리키고 있을 수도 있다. 그 곳에 13이라는 값을 저장하는 것이 오류를 발생시킬 수도 있는 말이다.

아래 코드와 같이 y = x; 라는 코드를 더해주면, y는 x가 가리키는 곳과 동일한 곳을 가리키게 된다.

따라서 \*y = 13; 으로 저장하면 x가 가리키는 곳에도 동일하게 13으로 저장될 것이다.

```c
y = x;

*y = 13;
```

포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까?

새로운 값을 입력할 때 포인터가 가르키고 있는 주소의 값을 덮어쓰게 되는 문제가 발생하고, 이로 인해 해당 주소에 저장되어 있던 값이 없어진다.

## 배열 크 조정하기

일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면 어떻게 해야 할까?

단순하게 현재 배열이 저장되어 있는 메모리 위치의 바로 옆에 일정 크기의 메모리를 더 덧붙이면 되겠지만, 실제로는 다른 데이터가 저장되어 있을 확률이 높다.

따라서 안전하게 새로운 공간에 큰 크기의 메모리를 다시 할당하고 기존 배열의 값들을 하나씩 옮겨줘야 한다.

따라서 이런 작업은 O(n), 즉 배열의 크기 n만큼의 실행 시간이 소요될 것이다.

이 과정을 아래 코드와 같이 나타낼 수 있다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```

위와 동일한 작업을 `realloc` 이라는 함수를 이용해서 수행할 수도 있다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유는 무엇인가?

이미 할당된 메모리의 근처에는 다른 데이터들이 존재할 수 있기 때문에 여유메모리가 없을 가능성이 있을 수 있다.
그렇기에 임시메모리를 할당하여 데이터를 옮겨주어야 한다.

## 연결 리스트: 도입

데이터 구조는 우리가 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체이다.
일종의 메모리 레이아웃, 또는 지도라고 생각할 수 있다.

데이터 구조중 하나인 연결 리스트에 대해 알아보겠다.

배열에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있다.

하지만 꼭 그럴 필요가 있을까? 각 값이 메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 여전히 값을 연이어서 읽어들일 수 있다.

이를 ‘연결 리스트’라고 한다. 아래 그림과 같이 크기가 3인 연결 리스트는 각 인덱스의 메모리 주소에서 자신의 값과 함께 바로 다음 값의 주소(포인터)를 저장한다.

연결 리스트의 가장 첫 번째 값인 1은 2의 메모리 주소를, 2는 3의 메모리 주소를 함께 저장하고 있다.

3은 다음 값이 없기 때문에 NULL (\0, 즉 0으로 채워진 값을 의미한다)을 다음 값의 주소로 저장한다.

<img src="./assets/linked_list_with_addresses.png" width="250">

연결 리스트는 아래 코드와 같이 간단한 구조체로 정의할 수 있다.

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

node 라는 이름의 구조체는 number 와 \*next 두 개의 필드가 함께 정의되어 있다.

number는 각 node가 가지는 값, \*next 는 다음 node를 가리키는 포인터가 된다.

여기서 typedef struct 대신에 typedef struct node 라고 ‘node’를 함께 명시해 주는 것은, 구조체 안에서 node를 사용하기 위함이다.

연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까?

배열처럼 매번 크기를 조정할 필요가 없고 기존 배열에서 하던 번거로운 과정을 하지 않아도 된다.
메모리에 이어서 연결된 공간이 없어도 빈공간을 찾아 유동적으로 데이터를 저장할 수 있다.
메모리를 효율적으로 사용가능하다.

저장되는 값 이외에도 next값의 메모리 주소를 저장해야한다. 메모리 저장 사용량 증가

## 연결 리스트: 코딩

앞서 정의한 구조체를 활용해서 실제로 연결 리스트를 구현하자.

```c
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number;

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의한다. 연결 리스트의 가장 첫 번째 node를 가리킬 것이다.
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화한다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킨다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장한다. “n->number”는 “(*n).numer”와 동일한 의미이다.
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것이다.
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장한다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화한다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 준다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당한다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장한다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node이다.
    //이 node의 다음 node를 n 포인터로 지정한다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장한다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있다.
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정한다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력한다.
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 된다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해준다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```

연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까?

노드 A와 B 사이에 C를 추가하기 위해서는 우선 C노드가 B를 향하도록 하고 B를 향하던 A노드 연결을 C로 변경한다.

노드 A, B, C 사이에 B를 삭제하기 위해서는 우선 B를 향하던 A노드를 C를 향하도록 변경한 뒤 B노드의 연결을 끊는다.

## 연결 리스트: 시연-비교

배열과 비교해서 연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있다.

하지만 이런 유동적인 구조는 그 대가가 따른다. 구조가 정적인 배열과 달리 연결 리스트에서는 임의 접근이 불가능하다.

연결 리스트에 값을 추가하거나 검색하는 경우를 생각해 보자.

이를 위해서는 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야 한다.

따라서 연결 리스트의 크기가 n 일때 그 실행 시간은 O(n)이 된다.

배열의 경우 임의 접근이 가능하기 때문에 (정렬 되어 있는 경우) 이진 검색을 이용하면 O(log n)의 실행 시간이 소요 되는 것에 비해서 다소 불리하다.

이처럼 여러 데이터 구조는 각각 장단점이 존재한다.

프로그래밍을 할 때 목적에 부합하는 가장 효율적인 데이터 구조를 고민해서 사용하는 것이 중요하다.

배열이 정렬되어 있지 않은 경우의 검색 소요 시간을 연결 리스트의 검색 시간과 비교해본다면,
배열이 정렬되어 있지 않다면 모든 값을 탐색해야 해서 연결 리스트의 검색 시간과 마찬가지로 O(n)이다.
